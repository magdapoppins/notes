# -*- coding: utf-8 -*-
"""Linked lists.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y12P8fCD4zqJo9fafc50VdhhieaaBrb6

# Linked lists 
- Contra to arrays, linked lists don't require a continuous chunk of memory, but can be located anywhere in memory
"""

# Create a class that represents a single node in a linked list
class Node:
  def __init__(self, data=None):
    self.data = data
    self.next: Node = None

# Create a class that represents a linked list
# Add a function to traverse the singly linked list and print its elements
class SinglyLinkedList:
  def __init__(self):
    self.head: Optional[Node] = None

  def print_list(self):
    ptr = self.head
    while ptr is not None:
      print(ptr.data, end=' -> ')
      ptr = ptr.next
    print("None")

# Create an instance of the linked list
my_list = SinglyLinkedList()

# Print the linked list
my_list.print_list()

# Create a node to represent the head of the Linked List
my_first_node = Node(1)
my_list.head = my_first_node

# Print the linked list
my_list.print_list()

# Insertion 
# Insert at the start
# Insert at a specific value
# Insert at the end
# Delete at value
# Delete at position

class SinglyLinkedList:
  def __init__(self):
    self.head: Optional[Node] = None
    self.length = 0

  def print_list(self):
    ptr = self.head
    while ptr is not None:
      print(ptr.data, end=' -> ')
      ptr = ptr.next
    print("None")

  def insert_beginning(self, data):
    node = Node(data)
    node.next = self.head
    self.head = node
    self.length += 1

  def insert_end(self, data):
    node = Node(data)
    ptr = self.head
    while ptr.next is not None:
      ptr = ptr.next
    ptr.next = node
    self.length += 1

  def insert_position(self, data, position: int):
    node = Node(data)
    ptr = self.head
    count = 0
    while count < position-1:
      if ptr.next is None:
        raise IndexError("Tried to insert at nonexistant position")
      ptr = ptr.next
      count += 1 
    node.next = ptr.next
    ptr.next = node
    self.length += 1

  def delete_position(self, position: int):
    if position == 0:
      self.head = self.head.next
    else:
      ptr = self.head
      counter = 0
      while counter > position - 1:
        counter += 1
        ptr = ptr.next
      rest_of_the_list = ptr.next.next
      ptr.next = rest_of_the_list
    self.length -= 1

  def delete_value(self, data):
      # if self.head == data:
      #   self.head = self.head.next
      # else:
      ptr = self.head
      while (ptr.next is not None) and (ptr.next.data != data):
        ptr = ptr.next
      if ptr.next.data == data:
        rest_of_the_list = ptr.next.next
        ptr.next = rest_of_the_list
        self.length -= 1

new_list = SinglyLinkedList()
new_list.insert_beginning(7)
new_list.print_list()

new_list.insert_end(5)
new_list.print_list()

new_list.insert_position(4, 1)
new_list.print_list()
new_list.insert_position(8, 2)
new_list.print_list()

new_list.delete_value(5)
new_list.print_list()

new_list.delete_position(0)
new_list.print_list()

# Reversing a linked list 

reversable_list = SinglyLinkedList()
reversable_list.insert_beginning(5)
reversable_list.insert_beginning(4)
reversable_list.insert_beginning(3)
reversable_list.insert_beginning(2)
reversable_list.insert_beginning(1)
reversable_list.print_list()

def reverse(linked_list: SinglyLinkedList) -> SinglyLinkedList:
  previous = None
  next = None
  current = linked_list.head
  while current.next is not None:
    # Store the remaining list in next
    next = current.next
    # Turn the arrow to point backwards from current
    current.next = previous
    # Move previous and current forwards
    previous = current
    current = next
  # Connect the last node to the rest and point the head at it
  current.next = previous
  linked_list.head = current
  return linked_list


reversed = reverse(reversable_list)
reversed.print_list()